# Prefácio da Nova Edição

O livro Estrutura e Interpretação de Programas de Computadores (_Structure and Interpretation of Computer Programs_ - SICP) apresenta ao leitor as ideias centrais de computação por meio da definição de uma série de modelos mentais para computação. Os capítulos 1 a 3 cobrem conceitos de programação que são comuns a todas as linguagens de programação modernas de alto nível. As duas primeiras edições desse livro utilizavam nos exemplos a linguagem de programação _Scheme_, cuja sintaxe minimalista e orientada a expressões permitiam ao livro manter o foco nas ideias subjacentes ao invés das decisões de projeto da linguagem escolhida. Os capítulos 4 e 5 usavam _Scheme_ para formular processadores de linguagens para _Scheme_, aprofundando a compreensão dos leitores sobre os modelos mentais e explorando as extensões e alternativas da linguagem.

Desde sua publicação em 1984 e sua segunda edição em 1996, SICP foi adotado como livro texto por universidades e faculdades ao redor do mundo, incluindo a Universidade Nacional de Cingapura (_National University of Singapore_ - NUS), que criou o curso introdutório baseado no SICP (CS1101S) em 1997. Em meados da década de 1990, as linguagens _Python_, _JavaScript_ e _Ruby_ surgiram, compartilhando elementos de projeto centrais com _Scheme_, mas empregam uma sintaxe orientada a sentenças mais complexa, usando uma notação infixa algébrica. O aumento de popularidade dessas linguagens motivou os professores a adaptarem suas disciplinas baseadas no SICP, geralmente traduzindo os programas exemplos para a linguagem preferida, adicionando material específico dela e omitindo o material dos capítulos 4 e 5.

## Adaptando SICP ao _JavaScript_

O trabalho de adaptar a segunda edição de SICP a _JavaScript_ (SICP JS) começou na NUS em 2008, e a disciplina CS1101S mudou para _JavaScript_ em 2012. O padrão da linguagem _ECMAScript_ 2015 introduziu expressões _lambda_, recursão em cauda e variáveis e constantes com escopo em bloco que permitiram a adaptação se aproximar bastante do original. Nós fizemos mudanças substanciais no SICP apenas quando sentimos que elas foram forçadas pelas diferenças entre _JavaScript_ e _Scheme_. O livro cobre apenas uma pequena fração da _JavaScript_, portanto não é aconselhável para um leitor utilizá-lo para aprender a linguagem. Por exemplo, a noção de um objeto _JavaScript_ - considerada um dos seus ingredientes fundamentais sob qualquer aspecto - não é sequer mencionada!
 
A tradução dos programas dos capítulos 1 e 3 para a _JavaScript_ foi direta, adicionando bibliotecas que espelhavam primitivas _Scheme_ - incluindo suporte para a estrutura de lista - e adaptando o texto da mesma forma. Entretanto, a mudança para _JavaScript_ nos forçou a fazer mudanças sutis no interpretador e compilador dos capítulos 4 e 5 para poder lidar com sentenças de retorno. A sintaxe orientada a expressões da _Scheme_ não tem sentenças de retorno, que são uma característica proeminente das linguagens orientadas a sentenças.  

Ao usar _JavaScript_, os capítulos 1 a 3 apresentam o leitor ao estilo sintático da maioria das principais linguagens da atualidade. Entretanto, esse mesmo estilo sintático originou várias mudanças no capítulo 4, pois a representam direta de programas como estruturas de dados não pode mais ser pressuposta. Isso nos forneceu uma oportunidade para apresentar ao leitor a noção de análise de programas na seção 4.1, um componente importante de processadores de linguagens de programação. Na seção 4.4, a estrutura sintática rígida da _JavaScript_ complicou a implementação do sistema de programação lógica apresentado e expôs a limitação da _JavaScript_ como uma ferramenta para projeto de linguagem de programação.

## Recursos para SICP JS

A página da _MIT Press_ na _web_ direciona para ajuda aos usuários desse livro. Lá temos todos os programas do livro e extensos recursos para o professor, incluindo uma grande coleção de exercícios adicionais e recomendações sobre como selecionar um subconjunto de SICP JS a ser coberto em um típico semestre universitário. Os programas _JavaScript_ do livro executam no modo restrito recomendado em qualquer interpretador que adote a especificação ECMAScript 2020 da linguagem. A página da _MIT Press_ inclui o pacote _JavaScript_ _sicp_, contendo todas as funções que são consideradas primitivas no livro. 

## Ao leitor

Nós esperamos com toda sinceridade que se este livro for seu primeiro contato com programação você usará o conhecimento recém adquirido sobre a estrutura e interpretação de programas de computador para aprender mais linguagens de programação, incluindo _Scheme_ e a linguagem _JavaScript_ completa. Se você já aprendeu _JavaScript_ antes de ter contato com SICP JS, você pode adquirir nova compreensão dos conceitos fundamentais da linguagem e descobrir como muito pode ser atingido a partir pouco. Se você está lendo SICP JS com conhecimento do SICP original, pode aproveitar para ver ideias similares apresentadas em um novo formato - e talvez utilizar a edição _online_ para comparação - disponível na página _web_ do livro, onde SICP JS e SICP podem ser vistos lado a lado. 

[Martin Henz](https://www.comp.nus.edu.sg/~henz/) e [Tobias Wrigstad](http://wrigstad.com/).

# Prefácio da Segunda Edição - 1995

> É possível que _software_ não seja como qualquer outra coisa, que é feito para ser descartado: a questão toda é sempre vê-lo como uma bolha de sabão? 

[Alan J. Perlis.](https://en.wikipedia.org/wiki/Alan_Perlis)

O material deste livro tem sido a base do curso introdutório em ciência da computação do MIT desde 1980. Nós ensinamos este material por quatro anos quando a primeira edição foi publicada e mais doze anos se passaram até o surgimento desta segunda edição. Sentimos muita satisfação no fato de que nosso texto foi amplamente adotado e incorporado em outros trabalhos. Nós presenciamos nossos estudantes utilizarem as ideias e programas deste livro  na construção do núcleo de novos sistema computacionais e linguagens. Na realização literal da doutrina judaica do Talmud, nossos estudantes se tornaram nossos mentores. Nós temos sorte de ter estudantes tão capazes e mentores com tantas realizações. 

No preparo desta edição, incorporamos centenas de clarificações sugeridas pela nossa própria experiência de ensino e pelos comentários de colegas do MIT e de outros lugares. Reestruturamos a maioria dos principais sistemas de programação no livro, incluindo o sistema de aritmética genérico, os interpretadores, o simulador de máquina de registradores e o compilador; e reescrevemos todos os exemplos de programas para garantir que qualquer implementação da _Scheme_ que obedeça o padrão IEEE _Scheme_ (IEEE 1990) será capaz de executar o código. 

Esta edição enfatiza vários tópicos novos. O mais importante deles é o papel central realizado por diferentes abordagens de como lidar com o conceito de tempo em modelos computacionais: objetos com estado, programação concorrente, programação funcional, avaliação preguiçosa e programação não determinística. Incluímos novas seções sobre concorrência e não determinismo e nos esforçamos para integrar esses temas no restante do livro.

A primeira edição do livro seguia fielmente o programa da nossa disciplina de um semestre oferecida no MIT. Com todo o novo material na segunda edição, não será possível cobrir todo o conteúdo em um único semestre, portanto o professor terá que fazer escolhas. Pela nossa experiência, algumas vezes pulamos a seção sobre programação lógica (seção 4.4), fazemos com que os alunos usem o simulador de máquina de registradores sem apresentar sua implementação (seção 5.2) e apresentamos apenas uma visão geral do compilador. Mesmo assim, trata-se de um curso intenso. Alguns professores podem desejar cobrir apenas os três ou quatro primeiros capítulos, deixando o material restante para outras disciplinas. 

A página na _World Wide Web_ da _MIT Press_ fornece suporte para usuários deste livro. Lá se encontra os programas do livro, exemplo de atividades de programação, material suplementar e implementações para baixar do dialeto _Scheme_ da _Lisp_.

[Harold Abelson](https://en.wikipedia.org/wiki/Hal_Abelson) e [Gerald Jay Sussman](https://en.wikipedia.org/wiki/Gerald_Jay_Sussman)

# Prefácio da Primeira Edição - 1984

> O computador é como um violino. Você pode imaginar um novato testando primeiro um fonógrafo e então um violino. O último, ele afirma, soa horrível. Este é o argumento que ouvimos de nossos humanistas e da maioria dos nossos cientistas da computação. Programas de computadores são bons, eles afirmam, para propósitos particulares, mas não são muito flexíveis. Assim como não é o violino, ou uma máquina de escrever, até que você aprenda a usá-los.

[Marvin Minsky](https://en.wikipedia.org/wiki/Marvin_Minsky), "Porque programação é um bom meio para expressar ideias pouco compreendidas e mal formuladas."

"A Estrutura e Interpretação de Programas de Computador" é a matéria introdutória em ciência da computação no MIT. É requisito para todos os estudantes que enfatizam engenharia elétrica ou ciência da computação, como um quarto do "currículo núcleo comum", que também inclui duas matérias sobre circuitos e sistemas lineares e uma disciplina sobre projeto de sistemas digitais. Nós estamos trabalhando no desenvolvimento dessa disciplina desde 1978, e ensinamos esse material na sua forma presente desde o outono de 1980 para cerca de 600 a 700 alunos todos os anos. A maioria desses alunos tem pouco ou nenhum conhecimento prévio formal em computação, apesar de terem brincado com computadores um pouco e alguns tem experiência extensa como programação ou projeto de _hardware_. 

Nosso projeto deste curso introdutório em ciência da computação reflete duas principais preocupações. Primeiro, queremos estabelecer a ideia de que uma linguagem de computador não é apenas uma maneira de fazer com que um computador execute operações mas sim um novo meio formal para expressar ideias sobre metodologia. Portanto, programas devem escritos para serem lidos por pessoas, e apenas executados por computadores de forma incidental. Segundo, acreditamos que o material essencial a ser tratado para uma disciplina no nível proposto não deve ser a sintaxe dos elementos de uma linguagem de programação particular, como também não deve ser algoritmos inteligentes para calcular certas funções de forma eficiente, e nem mesmo análise matemática de algoritmos e os fundamentos da computação, mas sim as técnicas usadas para controlar a complexidade intelectual de grandes sistemas de _software_.
 
Nosso objetivo é que estudantes que completem este curso tenham uma boa ideia dos elementos de estilo e estética da programação. Eles devem ter domínio das principais técnicas para controlar complexidade em um grande sistema. Eles devem ser capazes de ler um programa de 50 páginas, se for escrito em um estilo exemplar. Eles devem saber o que não deve ser lido e o que não precisam compreender em qualquer momento. Eles devem se sentir seguros ao modificar um programa, mantendo o espírito e estilo do autor original. 

Essas habilidades não são únicas para programação de computadores. As técnicas que ensinamos e utilizamos são comuns a todos projetos de engenharia. Controlamos complexidade ao construir abstrações que escondem detalhes quando apropriado. Controlamos complexidade ao estabelecer convenções de interface que permitem a construção de sistemas combinando elementos padronizados e bem compreendidos. Controlamos complexidade ao criar novas linguagens para descrever um projeto, cada uma enfatizando aspectos particulares do projeto e menosprezando outros.

A abordagem subjacente para este assunto é a nossa convicção de que "ciência da computação" não é uma ciência e que seu significado tem pouca relação computadores. A revolução dos computadores é uma revolução na maneira que pensamos e na maneira que expressamos o que pensamos. A essência dessa mudança é o surgimento do que pode ser melhor chamado _epistemologia procedimental_ - o estudo da estrutura do conhecimento de um ponto de vista imperativo, ao contrário de um ponto de vista mais declarativo adotado por assuntos com viés mais clássico da matemática. Matemática fornece um arcabouço para lidar precisamente com a noção "o que é". Computação fornece um arcabouço para lidar precisamente com noções de "como fazer".

Ao ensinar nosso material usamos um dialeto da linguagem de programação _Lisp_. Nunca ensinamos a linguagem formalmente, porque não precisamos. Apenas a usamos, e os estudantes a aprendem em alguns poucos dias. Esta é uma das grandes vantagens das linguagens inspiradas na _Lisp_: elas tem pouquíssimas maneiras de formar expressões compostas e praticamente não possuem estrutura sintática. Todas as estruturas formais podem ser ensinadas em uma hora, como as regras de xadrez. Após um curto período de tempo esquecemos dos detalhes sintáticos da linguagem (porque não existem) e partimos para os tópicos reais - descobrir o que desejamos calcular, como decompomos problemas em partes gerenciáveis e como trabalharemos com essas partes. Outra vantagem de _Lisp_ é que suporta (mas não obriga a utilizar) mais das estratégia de larga escala para decomposição modular de programas do qualquer outra linguagem que conhecemos. Podemos fazer abstração de dados e procedimentos, podemos usar funções de alta ordem para capturar padrões comuns de utilização, podemos modelar estado local usando atribuição e mutação de dados, podemos ligar partes de um programa com fluxos e avaliação atrasada e podemos facilmente implementar linguagens embarcadas. Tudo isso é embarcado em um ambiente interativo com excelente suporte para projeto incremental de programas, construção, teste e depuração. Agradecemos a todas as gerações de magos do _Lisp_, começando por John McCarthy, que criou uma boa ferramenta de poder e elegância sem precedentes.

_Scheme_, o dialeto de _Lisp_ que usamos, é uma tentativa de aproximar o poder e elegância de _Lisp_ e _Algol_. Da _Lisp_ utilizamos o poder metalinguístico derivado da sintaxe simples, a representação uniforme de programas como objetos de dados e a coleta de lixo para dados alocados no monte. Da _Algol_ usamos escopo léxico e estrutura de bloco, que são presentes dos pioneiros do projeto de linguagens que sentaram no comitê Algol. Gostaríamos de citar John Reynolds e Peter Landin por suas percepções no relacionamento do cálculo Lambda de Church com a estrutura das linguagens de programação. Também reconhecemos nossa dívida para os matemáticos que exploraram este território décadas antes dos computadores aparecerem. Esses pioneiros incluem Alonzo Church, Barkley Rosser, Stephen Kleene e Haskell Curry.   

[Harold Abelson](https://en.wikipedia.org/wiki/Hal_Abelson) e [Gerald Jay Sussman](https://en.wikipedia.org/wiki/Gerald_Jay_Sussman)



