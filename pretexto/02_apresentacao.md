# Apresentação

## Edição Atual

Eu tive o prazer de conhecer o espetacular Alan Perlis e conversar com ele algumas vezes, enquanto ainda era um estudante. Ele e eu tínhamos em comum um profundo amor e respeito por duas linguagens de programação bastante diferentes: _Lisp_ e APL. Seguir seus passos é uma tarefa assustadora, apesar dele ter deixado uma trilha excelente. Ainda assim, eu gostaria de examinar novamente um comentário que ele fez na apresentação original deste livro (e, por favor, eu sugiro que leia a apresentação dele, que está logo em seguida, antes de terminar esta). É realmente verdade que é melhor ter 100 funções atuando em única uma estrutura de dados do que ter 10 funções operando em 10 estruturas de dados?

Para responder essa questão com cuidado, primeiro devemos nos perguntar se a tal única estrutura de dados é "universal": pode ela, de maneira conveniente, cumprir o papel das outras 10 estruturas de dados mais especializadas?

No mesmo contexto, também podemos perguntar: realmente precisamos de 100 funções? Há uma única função universal que pode cumprir o papel de todas as outras funções?

A surpreende resposta para a última questão é **sim**; é apenas um pouco complicado construir uma função que receba (1) uma estrutura de dados que serve como descrição de alguma outra função e (2) uma lista de argumentos, e se comporta exatamente como essa outra função ao receber os mesmos argumentos. E também é apenas um pouco complicado projetar uma estrutura de dados capaz de descrever qualquer computação. Uma estrutura como essa (a representação em lista rotulada de expressões e sentenças, unida a um ambiente que associa nomes a valores) e uma função universal (aplicar) são descritas no Capítulo 04 deste livro. Então talvez precisamos apenas de uma função e uma estrutura de dados. _Nota do tradutor: o nome da estrutura em inglês é taggeg\_list e a função é apply. Talvez lá na frente não traduza esses termos._

Esta é a verdade na teoria. Na prática, encontramos conveniência ao delinear distinções que nos ajudam, como seres humanos criando descrições de computações, a organizar o formato de nosso código para facilitar sua compreensão. Eu acredito que Perlis estava fazendo uma afirmação não sobre capacidade computacional, mas sobre habilidades e limitações humanas.

Uma coisa que a mente humana parece fazer bem é nomear coisas; nós temos memórias associativas poderosas. Dado um nome, conseguimos rapidamente se lembrar de alguma coisa associada a ele. É por isso que geralmente achamos mais fácil trabalhar com o cálculo _lambda_ do que com o cálculo combinatório; é muito mais fácil para a maioria das pessoas interpretar a seguinte expressão _Lisp_ 

`(lambda(x)(lambda(y)(+ x y)))`

ou a expressão _JavaScript_

`x => y => x + y`

do que a expressão combinatória

`((S ((S (K S)) ((S ((S (K S)) ((S (K K)) (K +)))) ((S (K K)) I)))) (K I))` 

apesar de existir uma correspondência estrutural direta, facilmente expressa em algumas poucas linhas de código _Lisp_.

Então apesar de a princípio uma única função universal ser suficiente, preferimos modularizar o nosso código, nomear as diferentes partes e mencionar o nome das descrições de funções no lugar de repetidamente fornecer as descrições para uma função universal. 

Na minha palestra de 1998 chamada "Crescendo uma Linguagem", comentei que um bom programado "não apenas escreve programas. Um bom programador constrói um vocabulário funcional." A medida que projetamos e definimos mais e mais partes dos nossos programas, nomeamos essas partes e o resultado é que temos uma linguagem mais rica, na qual escrevemos o resto. 

Mas também achamos natural delinear distinções entre estruturas de dados e nomeá-las. 

Pode ocorrer de que listas aninhadas são uma estrutura de dados universal (e vale notar que muitas estruturas de dados modernas e amplamente utilizadas, como HTML, XML e JSON, são estruturas aninhadas entre parênteses, somente um pouco mais elaboradas do que os parênteses básicos de _Lisp_). Também há várias funções, tal como determinar o tamanho de uma lista ou aplicar uma função a cada elemento de uma lista e recuperar uma lista dos resultados, que são úteis em uma variedade de situações. Mas mesmo, quando estou pensando em uma computação específica, geralmente falo para comigo mesmo, "Esta lista de duas coisas considero como o primeiro nome e o sobrenome, mas aquela lista de duas coisas considero que são a parte real e imaginária de um número complexo, e aquela outra lista de duas coisas considero o numerador e o denominador de uma fração." Em outras palavras, eu descrevo distinções - e pode ser útil representar tais distinções de maneira explícita na estrutura de dados, em parte para prevenir erros como acidentalmente tratar um número complexo como uma fração. (Novamente, este é um comentário sobre habilidades e limitações humanas.)

Desde que a primeira edição deste livro foi escrita, quase quatro décadas atrás, muito mais maneiras de organizar dados se tornaram relativamente padronizadas, em particular a abordagem "orientada a objetos", e muitas linguagens, incluindo _JavaScript_, suportam estruturas de dados especializadas como objetos, cadeias de caracteres, monte (_heap_), pilhas e mapeamentos com uma variedade de mecanismos embutidos e bibliotecas. Mas ao fazer isso, muitas linguagens abandonam o suporte para noções mais gerais e universais. _Java_, por exemplo, originalmente não suportava funções de primeira classe e as incorporou apenas recentemente, aumentando em muito seu poder de expressão.

APL, da mesma forma, originalmente não suportava funções de primeira classe e sua única estrutura de dados inicial - _arrays_ de qualquer número de dimensões - não era tão útil como uma estrutura universal porque _arrays_ não podiam conter outros _arrays_ como elementos. Versões mais recentes da APL suportam valores de função anônimos e _arrays_ aninhados e estas adições tornaram API dramaticamente mais expressiva. (O projeto inicial da APL tinha sim duas boas decisões a seu favor: um conjunto abrangente de funções aplicáveis para a única estrutura de dados e um conjunto de nomes para essas funções bem definido. Não estou falando dos símbolos engraçados e letras gregas, mas das palavras faladas que programadores APL usam quando os referenciam, palavras como _shape_, _reshape_, _compress_, _expand_ e _laminate_; estes são nomes não para os símbolos, mas para as funções que representam. Ken Iverson tinha um grande talento para escolher nomes cursos, fáceis de lembrar e vívidos para funções em _arrays_.) _Nota do tradutor: preferi por não traduzir as funções do APL, até porque não devem retornar a aparecer no resto do livro._

Enquanto _JavaScript_, como _Java_, foi originalmente projetada com objetos e métodos em mente, também incorporou funções de primeira classe desde o início e agora não é difícil usar seus objetos para definir uma estrutura de dados universal. Como resultado, _JavaScript_ não é tão distante de _Lisp_ quanto você pensa e como esta nova edição demonstra, é um bom _framework_ alternativo para apresentar as ideias chave. Este livro nunca foi pensando como um livro sobre uma linguagem de programação; ele apresenta ideias gerais e poderosas para organização de programas que podem ser úteis em qualquer linguagem.

O que _Lisp_ e _JavaScript_ tem em comum? A habilidade de abstrair uma computação (código mais alguns dados associados) para posterior execução como uma função; a habilidade de embarcar referências a tais funções dentro de estruturas de dados; a habilidade de invocar funções em argumentos; a habilidade de delinear uma distinção (execução condicional); uma estrutura de dados universal conveniente; gestão totalmente automática de armazenamento para os dados (o que parece algo básico, dadas todas características já citadas, até você perceber que várias linguagens de programação amplamente utilizadas não tem essa característica); um grande conjunto de funções úteis para operar na estrutura de dados universal; e estratégias padrão para utilizar a estrutura de dados universal para representar estruturas de dados mais especializadas.

Então talvez a verdade esteja em algum lugar entre os extremos que Perlis apresentou de forma tão eloquente. Talvez o ponto de equilíbrio seja mais algo como 40 funções gerais o suficiente para operar de forma útil em uma estrutura de dados universal como listas, mas também 10 conjuntos de 6 funções que são relevantes quando tomamos uma das 10 visões especializadas daquela estrutura de dados universal. Isto é gerenciável se dermos bons nomes para essas funções e visões especializadas. 

A medida que você ler este livro, preste atenção não apenas para as construções de linguagem de programa e como elas são utilizadas, mas também para os _nomes_ dados para funções, variáveis e estruturas de dados. Eles não são tão curtos e vívidos como os nomes que Iverson escolheu para suas funções APL, mas eles foram escolhidos de forma deliberada e sistemática para aprimorar sua compreensão da estrutura geral do programa.

Primitivas, meios de combinação, abstrações funcionais, nomeação e convenções para utilizar uma estrutura de dados universal de maneira especializada ao delinear distinções: estes são os blocos fundamentais de uma boa linguagem de programação. A partir daí, imaginação e bom julgamento de engenharia baseado em experiência podem fazer o resto.

[Guy L. Steel Jr.](https://en.wikipedia.org/wiki/Guy_L._Steele_Jr.), Lexington, Massachusetts, 2021.  


## Edição de 1984

Educadores, generais, nutricionistas, psicólogos e pais programam. Exércitos, estudantes e algumas sociedades são programados. A resolução de grandes problemas envolve uma sucessão de programas, a maioria dos quais são criados enquanto o problema é resolvido. Esses programas estão repletos de questões que parecem ser particulares ao problema em questão. Para apreciar programação como uma atividade intelectual autônoma você deve voltar sua atenção para programação de computadores; você deve ler e escrever programas de computador - muitos deles. Não importa muito sobre o que os programas são ou quais aplicações eles atendem. O que importa é o quão bem eles executam e como se encaixam de forma suave com outros programas na criação de programas ainda maiores. O programador deve procurar tanto perfeição das partes quanto a adequação da coleção. Neste livro o uso do termo "programa" está relacionado à criação, execução e estudo de programas escritos em um dialeto de _Lisp_ para execução em um computador digital. Usar _Lisp_ restringimos ou limitamos não que podemos programas, mas apenas a notação para nossas descrições de programa.

Nosso passeio com o assunto deste livro nos envolve com três focos do fenômeno: a mente humana, coleções de programas de computadores e o computador. Cada programa de computador é um modelo, que surge na mente, de um processo real ou mental. Esses processos, surgindo da experiência e pensamento humano, são grandes em número, intricados em detalhes e a qualquer momento, apenas parcialmente entendidos. Eles raramente são modelados em programas de computador de forma a fornecer satisfação permanente. Portanto, apesar de nossos programas serem coleções discretas de símbolos e mosaicos de funções interligadas, cuidadosamente criadas de forma manual, eles evoluem continuamente: nós os alteramos a medida que a percepção do modelo se aprofunda, se expande e se generaliza até o modelo acabar por atingir um espaço meta-estável dentro de outro modelo com o qual lutamos. A fonte da alegria associada com programação de computadores é o contínuo desdobramento dentro da mente e nos mecanismos do computador expresso como programas e a explosão de percepção que eles geram. Se arte interpreta nossos sonhos, o computador os executa sob disfarce de programas!

Apesar de todo seu poder, o computador é um trabalhador braçal. Seus programas devem estar corretos e que nós queremos expressar deve ser dito da forma mais precisa em cada detalhe. Como qualquer outra atividade simbólica, nós nos convencemos da verdade do programa através de argumentação. A própria _List_ pode ter uma semântica atribuída (a propósito, um outro modelo) e se o funcionamento de um programa pode ser detalhado, digamos, através do cálculo de predicados, os métodos de prova da lógica podem ser usados para fazer uma argumentação aceitável de corretude. Infelizmente, a medida que programas se tornam maiores e mais complicados, como sempre ocorre, a adequação, consistência e corretude das próprias especificações se tornam abertas a dúvidas, de forma que a argumentação formal completa da corretude raramente é feita para programas grandes. Já que programas grandes surgem a partir de programas pequenos, é crucial que desenvolvamos um arsenal de estruturas de programa padronizadas das quais tenhamos certeza da corretude - vamos chamá-las de idiomas - e sejamos capazes de combiná-las em estruturas maiores usando técnicas organizacionais de valor comprovado. Essas técnicas são tratadas em profundidade neste livro e compreendê-las é essencial para tomar parte no empreendimento hercúleo chamado programação. Mais do que qualquer coisa, a descoberta e domínio de técnicas organizacionais poderosas aceleram nossa habilidade de criar programas amplos e significativos. Da mesma forma, já que escrever programas grandes é muito oneroso, somos estimulados a inventar novos métodos de reduzir a massa de função e detalhes a ser encaixada em grandes programas.

Ao contrário de programas, computadores devem obedecer as regras da físicas. Se desejam executar rápido - poucos nanosegundos por mudança de estado - eles devem transmitir elétrons a uma distância curta (no máximo 45 cm). O calor gerado pela quantidade enorme de dispositivos aglomerados no espaço também precisa ser removido. Uma arte de engenharia complexa foi desenvolvida balanceando a multiplicidade de funções e densidade de dispositivos. Em qualquer momento, _hardware_ sempre opera em um nível mais primitivo do que gostaríamos de programar. Os processos que transformam nossos programas em _Lisp_ para programas de "máquina" são também modelos abstratos que nós programamos. Seu estudo e criação fornecem uma grande quantidade de compreensão nos programas organizacionais associados com a programação de modelos arbitrários. É claro que o próprio computador pode ser modelado desta forma. Pense o seguinte: o comportamento do menor elemento comutador é modelado pela mecânica quântica descrita por equações diferenciais cujo comportamento detalhado é capturado por aproximações numéricas representadas em programas de computador executando em computadores feitos de ...!

Não é apenas uma conveniência tática identificar separadamente os três focos. Mesmo que, como afirmam, está tudo dentro da cabeça, essa separação lógica induz uma aceleração de tráfego simbólico entre os focos cuja riqueza, vitalidade e potencial é excedido na experiência humana apenas pela própria evolução da vida. No melhor dos casos, os relacionamentos entre os focos são meta-estáveis. Os computadores nunca são grande ou rápidos suficientes. Cada avanço em tecnologia de _hardware_ leva a empreitadas de programas maiores, novos princípios organizacionais e um enriquecimento de modelos abstratos. Cada leitor deve se perguntar de vez em quando "Em direção a qual fim, em direção a qual fim?" -  mas não faça essa pergunta de forma tão frequente a não que deseje trocar a diversão de programar pela constipação de amargura da filosofia.

Entre os programas que escrevemos, alguns (mas nunca o suficiente) realizam uma função matemática precisa tal como ordenação ou achar o máximo em uma sequência de números, determinar se dado número é primo ou encontrar a raiz quadrada. Chamamos tais programas algoritmos e uma grande quantidade de informação é conhecida de seu comportamento ótimo, particularmente em respeito aos dois importantes parâmetros de requisitos de tempo de execução e armazenamento de dados. Um programador deve possuir bons algoritmos e idiomas. Mesmo que alguns programas resistam a especificações precisas, é responsabilidade do programador estimar, e sempre tentar aprimorar, seu desempenho. 

_Lisp_ é uma sobrevivente, tendo sido usada por aproximadamente um quarto de século. Dentre as linguagens de programação ativas apenas _Fortran_ tem uma vida mais longa. Ambas linguagens atenderam as necessidades de desenvolvimento de importantes áreas de aplicação, _Fortran_ para computações científicas e da engenharia e _Lisp_ para inteligência artificial. Essas duas áreas continuam a ser importantes, e seus programadores são tão devotados a essas duas linguagens que _Lisp_ e _Fortran_ podem continuarem a ser ativamente utilizadas por pelo menos outro quarto de século.

_Lisp_ muda. O dialeto _Scheme_ usando neste texto evoluiu do _Lisp_ original e difere em vários pontos importantes, incluindo escopo estático para vinculação de variáveis e permitindo a funções produzir outras funções como valores. Na sua estrutura semântica, _Scheme_ é tão próxima de _Algol 60_ quanto das _Lisps_ originais. _Algol 60_, nunca voltará a ser uma linguagem ativa, vive nos genes de _Scheme_ e _Pascal_. Seria difícil encontrar duas linguagens que são o elo de comunicação de duas culturas mais diferentes do que aquelas reunidas ao redor dessas duas linguagens. _Pascal_ serve para construir pirâmides - estruturas estáticas e imponentes de tirar o fôlego, construídas por exércitos empurrando blocos pesados para o local certo. _Lisp_ serve para construir organismos - estruturas dinâmicas e imponentes, construídas por esquadrões encaixando miríades flutuantes de organismos mais simples nos locais certos. Os princípios organizacionais usados são os mesmos em ambos os casos, exceto por uma diferença extraordinária importante: A funcionalidade discricionária exportável delegada ao programador _Lisp_ individual é mais do que uma ordem de magnitude maior do que a encontrada dentro de empreitadas _Pascal_. Programadores _Lisp_ preenchem bibliotecas com funções cuja utilidade transcende a aplicação que as produziu. A lista, estrutura de dados nativa da _Lisp_, é amplamente responsável for tal aumento de utilidade. A estrutura simples e aplicabilidade natural das listas refletem em funções que são espantosamente não idiossincráticas. Em _Pascal_ a pletora de estrutura de dados declaráveis induz a especialização dentro de funções que inibe e penaliza cooperação casual. É melhor ter 100 funções operando em uma única estrutura de dados do que 10 funções operando em 10 estruturas de dados. Como resultado, a pirâmide deve se manter imutável por um milênio; o organismo deve evoluir ou perecer.

Para ilustrar essa diferença, compare o tratamento do material e exercícios neste livro com qualquer curso introdutório usando _Pascal_. Não alimente a ilusão que este é um texto aceitável apenas para o MIT, peculiar aos alunos encontrados lá. É precisamente o que um livro sério sobre _Lisp_ deve ser, não importa quem seja o estudante e onde seja aplicado. 

Perceba que este é um texto sobre programação, ao contrário da maioria dos livros de _Lisp_, que são usados como preparação para atuar em inteligência artificial. Afinal, os interesses críticos envolvendo programação na engenharia de _software_ e inteligência artificial tendem a se unificar a medida que os sistemas sob investigação se tornam maior. Isso explica porque há tanto interesse crescente em _Lisp_ fora da inteligência artificial.

Como alguém poderia esperar a partir dos seus objetivos, a pesquisa em inteligência artificial cria vários problemas de programação significantes. Em outras culturas de programação essa onda de problemas acaba gerando novas linguagens. De fato, em qualquer tarefa de programação grande um princípio organizacional útil é controlar e isolar o tráfego dentro dos módulos da tarefa através da invenção de linguagens. Essas linguagens tendem a se tornar menos primitivas a medida que se aproximamos dos limites do sistema, onde os humanos interagem com maior frequência. Como resultado, tais sistemas contém funções complexas de processamento de linguagem replicadas várias vezes. _Lisp_ tem uma sintaxe e semântica tão simples que a análise pode ser tratada como uma tarefa elementar. Portanto, a tecnologia de análise quase que não desempenha papel em programas _Lisp_ e a construção de processadores de linguagens quase nunca é um impedimento para a taxa de crescimento e mudança de grandes sistemas _Lisp_. Por fim, é sua própria simplicidade de sintaxe e semântica que é responsável pelo fardo e liberdade suportados por todos programadores _Lisp_. Nenhum programa _Lisp_ de qualquer tamanho além de umas poucas linhas pode ser escrito sem se tornar saturado com funções discricionárias. Inventar e encaixar, ajustar e reinventar! Brindamos ao programador _Lisp_ que anota seus pensamentos dentro de parênteses aninhados.    

[Alan J. Perlis](https://en.wikipedia.org/wiki/Alan_Perlis), New Haven, Connecticut.  




